#实验报告 死锁
##死锁停在第几次的截图
![](https://github.com/linzoe8100/ES2016_14353178/blob/master/360截图20161025001233297.jpg)

##产生死锁的4个必要条件

###1）资源互斥
每个资源每次只能供一个进程使用
###2）非抢占
除非资源使用者主动放弃资源，否则其他申请者无法使用该资源
###3）请求与保持
一个进程因请求资源而阻塞时，对已获得的资源保持不放
###4）循环等待条件
进程之间形成一种头尾相接的循环等待资源关系

##对上述程序产生死锁的解释
a，b两个实例中的所有函数可以看做两个临界区，只能每次被一个进程占有。t线程开始后，a中的methodA函数被a占用，b中的method函数被b占有，但两个动作不清楚谁先谁后。此时，如果a在methodA函数中申请b，而b刚好已经被占用，且刚好也申请a，则造成死锁。